var x=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var S=Object.getOwnPropertyNames;var _=Object.prototype.hasOwnProperty;var u=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of S(t))!_.call(e,o)&&o!==r&&x(e,o,{get:()=>t[o],enumerable:!(n=w(t,o))||n.enumerable});return e},p=(e,t,r)=>(u(e,t,"default"),r&&u(r,t,"default"));var s={};p(s,E);import*as E from"https://registry.koishi.chat/modules/koishi/index.js";var v=Object.defineProperty,O=(e,t,r)=>t in e?v(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,a=(e,t)=>v(e,"name",{value:t,configurable:!0}),k=(e,t,r)=>(O(e,typeof t!="symbol"?t+"":t,r),r),b=class extends s.Service{constructor(e,t,r={}){super(e,`console.${t}`,r.immediate),this.ctx=e,this.key=t,this.options=r,b.define(t)}static define(e){if(this.keys.add(e),Object.prototype.hasOwnProperty.call(y.prototype,e))return;let t=`console.${e}`;Object.defineProperty(y.prototype,e,{get(){return this.caller[t]},set(r){this.caller[t]=r}})}get(e){return null}start(){this.refresh()}async refresh(){this.ctx.console?.broadcast("data",{key:this.key,value:await this.get(!0)},this.options)}patch(e){this.ctx.console?.broadcast("patch",{key:this.key,value:e},this.options)}},c=b;a(c,"DataService");k(c,"keys",new Set);var f=new s.Logger("console"),h=class{constructor(e,t){this.ctx=e,this.socket=t,t.onmessage=this.receive.bind(this),e.on("ready",()=>{e.console.handles[this.id]=this,this.refresh()})}id=s.Random.id();send(e){this.socket.send(JSON.stringify(e))}async receive(e){let{type:t,args:r,id:n}=JSON.parse(e.data.toString()),o=this.ctx.console.listeners[t];if(!o)return f.info("unknown message:",t,...r),this.send({type:"response",body:{id:n,error:"not implemented"}});if(await this.ctx.serial("console/intercept",this,o))return this.send({type:"response",body:{id:n,error:"unauthorized"}});try{let i=await o.callback.call(this,...r);return this.send({type:"response",body:{id:n,value:i}})}catch(i){f.debug(i);let g=(0,s.coerce)(i);return this.send({type:"response",body:{id:n,error:g}})}}refresh(){c.keys.forEach(async e=>{let t=this.ctx[`console.${e}`];if(!!t){if(await this.ctx.serial("console/intercept",this,t.options))return this.send({type:"data",body:{key:e,value:null}});try{let r=await t.get();if(!r)return;this.send({type:"data",body:{key:e,value:r}})}catch(r){this.ctx.logger("console").warn(r)}}})}};a(h,"SocketHandle");var m=class extends c{constructor(e){super(e,"entry",{immediate:!0})}async get(){return this.ctx.console.get()}};a(m,"EntryProvider");var l=class extends s.Service{constructor(e){super(e,"console",!0),this.ctx=e,e.plugin(m)}entries=Object.create(null);listeners=Object.create(null);handles=Object.create(null);async get(){return Object.values(this.entries).flat()}addEntry(e){let t=this.caller,r="extension-"+s.Random.id();this.entries[r]=(0,s.makeArray)(this.resolveEntry(e)),this.entry.refresh(),t?.on("dispose",()=>{delete this.entries[r],this.entry?.refresh()})}addListener(e,t,r){this.listeners[e]={callback:t,...r}}broadcast(e,t,r={}){if(!Object.values(this.handles).length)return;let o=JSON.stringify({type:e,body:t});Promise.all(Object.values(this.handles).map(async i=>{await this.ctx.serial("console/intercept",i,r)||i.socket.send(o)}))}};a(l,"Console");var y=l;var P=Object.defineProperty,j=(e,t)=>P(e,"name",{value:t,configurable:!0}),d=class extends l{start(){new h(this.ctx,this.ctx.loader[Symbol.for("koishi.socket")])}resolveEntry(e){return typeof e=="string"||Array.isArray(e)?e:e.prod}};j(d,"BrowserConsole");(e=>{e.Config=s.Schema.object({})})(d||(d={}));var F=d;export{l as Console,c as DataService,m as EntryProvider,h as SocketHandle,F as default};
